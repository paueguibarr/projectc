Consider the following assembly code:
// x at %ebp + 8, n at %ebp + 12
1 movl 8(%ebp), %esi
2 movl 12(%ebp), %ebx
3 movl $-1, %edi
4 movl $1, %edx
5 .L2
6 movl %edx, %eax // %eax = mask 
7 andl %esi, %eax // MASK & x
8 xorl %eax, %edi // result ^= mask & x
9 movl %ebx, %ecx 
10 sall %cl, %edx // mask = mask << n
11 testl %edx, %edx not 0
12 jne L2
13 movl %edi, %eax
The preceding code was generated by compiling C code that had the following overall form:
1 int loop(int x, int n)
2 {
3 int result = -1;
4 int mask;
5 for(mask = 1; mask !=0; mask  << n ) {
6 result ^= mask & x;
7 }
8 return result;
9 }
Your task is to fill in the missing parts of the C code to get a program equivalent to the
generated assembly code. Recall that the result of the function is returned in register %eax. You
will find it helpful to examine the assembly code before, during, and after the loop to form a
consistent mapping between the registers and the program variables.
A. Which registers hold program values x, n, result, and mask?
x = %esi n = %ebx result = %edi mask = %edx

B. What are the initial values of result and mask? result = -1, mask = 1

C. What is the test condition for mask? testl %edx, %edx if test is not 0 (mask !=0)

D. How does mask get updated? sall %cl, %edx (mask = mask << n)

E. How does result get updated? xorl %eax, %edi (result ^= mask & x)

F. Fill in all the missing parts of the C code 